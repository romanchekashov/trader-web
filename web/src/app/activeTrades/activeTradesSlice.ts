import {
  createAsyncThunk,
  createSelector,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
import { ActiveTrade } from "../../common/data/ActiveTrade";
import { LoadingState } from "../LoadingState";
import { handleThunkError } from "../reduxUtils";
import { RootState } from "../store";
import activeTradesApi from "./activeTradesApi";

export interface ActiveTradesState {
  activeTrades: ActiveTrade[];
  activeTradesLoading: LoadingState;
  activeTradesLoadingError?: string;

  selectedActiveTrade?: ActiveTrade;
  deleteActiveTradesLoading: LoadingState;
  deleteActiveTradesLoadingError?: string;
}

export const initialState: ActiveTradesState = {
  activeTrades: [],
  activeTradesLoading: LoadingState.IDLE,
  deleteActiveTradesLoading: LoadingState.IDLE,
};

export const loadActiveTrades = createAsyncThunk<ActiveTrade[]>(
  "activeTrades/loadActiveTrades",
  async (_, thunkAPI) =>
    await handleThunkError(thunkAPI, activeTradesApi.getActiveTrades())
);

export const deleteActiveTrades = createAsyncThunk<void, number>(
  "activeTrades/deleteActiveTrades",
  async (secId, thunkAPI) =>
    await handleThunkError(thunkAPI, activeTradesApi.deleteActiveTrades(secId))
);

export const activeTradesSlice = createSlice({
  name: "activeTrades",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setActiveTrades: (state, { payload }: PayloadAction<ActiveTrade[]>) => {
      state.activeTrades = payload;
    },
    setSelectedActiveTrade: (
      state,
      { payload }: PayloadAction<ActiveTrade>
    ) => {
      state.selectedActiveTrade = payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    [loadActiveTrades.pending as any]: (state: ActiveTradesState) => {
      state.activeTrades = [];
      state.activeTradesLoading = LoadingState.LOADING;
    },
    [loadActiveTrades.fulfilled as any]: (
      state: ActiveTradesState,
      action: PayloadAction<ActiveTrade[]>
    ) => {
      state.activeTrades = action.payload;
      state.activeTradesLoading = LoadingState.LOADED;
    },
    [loadActiveTrades.rejected as any]: (
      state: ActiveTradesState,
      action: PayloadAction<any>
    ) => {
      state.activeTradesLoadingError = action.payload;
      state.activeTradesLoading = LoadingState.ERROR;
    },
    // deleteActiveTrades
    [deleteActiveTrades.pending as any]: (state: ActiveTradesState) => {
      state.deleteActiveTradesLoading = LoadingState.LOADING;
    },
    [deleteActiveTrades.fulfilled as any]: (
      state: ActiveTradesState,
      action: PayloadAction<void>
    ) => {
      state.activeTrades = state.activeTrades.filter(
        ({ secId }) => secId !== state.selectedActiveTrade?.secId
      );
      state.selectedActiveTrade = undefined;
      state.deleteActiveTradesLoading = LoadingState.LOADED;
    },
    [deleteActiveTrades.rejected as any]: (
      state: ActiveTradesState,
      action: PayloadAction<any>
    ) => {
      state.deleteActiveTradesLoadingError = action.payload;
      state.deleteActiveTradesLoading = LoadingState.ERROR;
    },
  },
});

export const { setActiveTrades, setSelectedActiveTrade } =
  activeTradesSlice.actions;

export const selectActiveTrades = createSelector(
  (state: RootState) => ({
    activeTrades: state.activeTrades.activeTrades,
    activeTradesLoading: state.activeTrades.activeTradesLoading,
    activeTradesLoadingError: state.activeTrades.activeTradesLoadingError,

    selectedActiveTrade: state.activeTrades.selectedActiveTrade,
    deleteActiveTradesLoading: state.activeTrades.deleteActiveTradesLoading,
    deleteActiveTradesLoadingError:
      state.activeTrades.deleteActiveTradesLoadingError,
  }),
  (state) => state
);

export default activeTradesSlice.reducer;
