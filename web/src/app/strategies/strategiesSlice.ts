import {
  createAsyncThunk,
  createSelector,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
import { TradingStrategyResult } from "../../common/data/history/TradingStrategyResult";
import { Page } from "../../common/data/Page";
import { SecurityInfo } from "../../common/data/security/SecurityInfo";
import { TradingStrategyStatus } from "../../common/data/trading/TradingStrategyStatus";
import { LoadingState } from "../LoadingState";
import { handleThunkError } from "../reduxUtils";
import { RootState } from "../store";
import strategiesApi from "./strategiesApi";

export interface StrategiesState {
  strategiesSecurities: SecurityInfo[];
  strategiesSecuritiesLoading: LoadingState;
  strategiesSecuritiesLoadingError?: string;

  strategyResultsRunning: Page<TradingStrategyResult>;
  strategyResultsRunningLoading: LoadingState;
  strategyResultsRunningLoadingError?: string;

  strategyResultsStopped: Page<TradingStrategyResult>;
  strategyResultsStoppedLoading: LoadingState;
  strategyResultsStoppedLoadingError?: string;

  strategyResultsHistory: Page<TradingStrategyResult>;
  strategyResultsHistoryLoading: LoadingState;
  strategyResultsHistoryLoadingError?: string;
}

export const initialState: StrategiesState = {
  strategiesSecurities: [],
  strategiesSecuritiesLoading: LoadingState.IDLE,

  strategyResultsRunning: {
    content: [],
    first: false,
    last: false,
    totalElements: 0,
    totalPages: 0
  },
  strategyResultsRunningLoading: LoadingState.IDLE,

  strategyResultsStopped: {
    content: [],
    first: false,
    last: false,
    totalElements: 0,
    totalPages: 0
  },
  strategyResultsStoppedLoading: LoadingState.IDLE,

  strategyResultsHistory: {
    content: [],
    first: false,
    last: false,
    totalElements: 0,
    totalPages: 0
  },
  strategyResultsHistoryLoading: LoadingState.IDLE
};

export const loadStrategiesSecurities = createAsyncThunk<SecurityInfo[]>(
  "strategies/loadStrategiesSecurities",
  async (data, thunkAPI) =>
    await handleThunkError(thunkAPI, strategiesApi.getAllStrategiesSecurities())
);

export const loadStrategiesRunning = createAsyncThunk<Page<TradingStrategyResult>, { secId?: number, page: number, size: number }>(
  "strategies/loadStrategiesRunning",
  async (data, thunkAPI) =>
    await handleThunkError(thunkAPI, strategiesApi.getAllStrategies(data.secId, TradingStrategyStatus.RUNNING, data.page, data.size))
);

export const loadStrategiesStopped = createAsyncThunk<Page<TradingStrategyResult>, { secId?: number, page: number, size: number }>(
  "strategies/loadStrategiesStopped",
  async (data, thunkAPI) =>
    await handleThunkError(thunkAPI, strategiesApi.getAllStrategies(data.secId, TradingStrategyStatus.STOPPED, data.page, data.size))
);

export const loadStrategiesHistory = createAsyncThunk<Page<TradingStrategyResult>, { secId?: number, page: number, size: number }>(
  "strategies/loadStrategiesHistory",
  async (data, thunkAPI) =>
    await handleThunkError(thunkAPI, strategiesApi.getAllStrategies(data.secId, TradingStrategyStatus.FINISHED, data.page, data.size))
);

export const strategiesSlice = createSlice({
  name: "strategies",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setRunning: (state, { payload }: PayloadAction<TradingStrategyResult[]>) => {
      state.strategyResultsRunning = {
        ...initialState.strategyResultsRunning,
        content: payload,
        totalElements: payload.length,
        totalPages: 1
      };
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    [loadStrategiesSecurities.pending as any]: (state: StrategiesState) => {
      state.strategiesSecuritiesLoading = LoadingState.LOADING;
    },
    [loadStrategiesSecurities.fulfilled as any]: (
      state: StrategiesState,
      action: PayloadAction<SecurityInfo[]>
    ) => {
      state.strategiesSecurities = action.payload;
      state.strategiesSecuritiesLoading = LoadingState.LOADED;
    },
    [loadStrategiesSecurities.rejected as any]: (
      state: StrategiesState,
      action: PayloadAction<any>
    ) => {
      state.strategiesSecuritiesLoadingError = action.payload;
      state.strategiesSecuritiesLoading = LoadingState.ERROR;
    },
    // running
    [loadStrategiesRunning.pending as any]: (state: StrategiesState) => {
      state.strategyResultsRunningLoading = LoadingState.LOADING;
    },
    [loadStrategiesRunning.fulfilled as any]: (
      state: StrategiesState,
      action: PayloadAction<Page<TradingStrategyResult>>
    ) => {
      state.strategyResultsRunning = action.payload;
      state.strategyResultsRunningLoading = LoadingState.LOADED;
    },
    [loadStrategiesRunning.rejected as any]: (
      state: StrategiesState,
      action: PayloadAction<any>
    ) => {
      state.strategyResultsRunningLoadingError = action.payload;
      state.strategyResultsRunningLoading = LoadingState.ERROR;
    },
    // stopped
    [loadStrategiesStopped.pending as any]: (state: StrategiesState) => {
      state.strategyResultsStoppedLoading = LoadingState.LOADING;
    },
    [loadStrategiesStopped.fulfilled as any]: (
      state: StrategiesState,
      action: PayloadAction<Page<TradingStrategyResult>>
    ) => {
      state.strategyResultsStopped = action.payload;
      state.strategyResultsStoppedLoading = LoadingState.LOADED;
    },
    [loadStrategiesStopped.rejected as any]: (
      state: StrategiesState,
      action: PayloadAction<any>
    ) => {
      state.strategyResultsStoppedLoadingError = action.payload;
      state.strategyResultsStoppedLoading = LoadingState.ERROR;
    },
    // history
    [loadStrategiesHistory.pending as any]: (state: StrategiesState) => {
      state.strategyResultsHistoryLoading = LoadingState.LOADING;
    },
    [loadStrategiesHistory.fulfilled as any]: (
      state: StrategiesState,
      action: PayloadAction<Page<TradingStrategyResult>>
    ) => {
      state.strategyResultsHistory = action.payload;
      state.strategyResultsHistoryLoading = LoadingState.LOADED;
    },
    [loadStrategiesHistory.rejected as any]: (
      state: StrategiesState,
      action: PayloadAction<any>
    ) => {
      state.strategyResultsHistoryLoadingError = action.payload;
      state.strategyResultsHistoryLoading = LoadingState.ERROR;
    },
  },
});

export const { setRunning } = strategiesSlice.actions;

export const selectStrategies = createSelector(
  (state: RootState) => ({
    strategiesSecurities: state.strategies.strategiesSecurities,
    strategiesSecuritiesLoading: state.strategies.strategiesSecuritiesLoading,
    strategiesSecuritiesLoadingError: state.strategies.strategiesSecuritiesLoadingError,

    strategyResultsRunning: state.strategies.strategyResultsRunning,
    strategyResultsRunningLoading: state.strategies.strategyResultsRunningLoading,
    strategyResultsRunningLoadingError: state.strategies.strategyResultsRunningLoadingError,

    strategyResultsStopped: state.strategies.strategyResultsStopped,
    strategyResultsStoppedLoading: state.strategies.strategyResultsStoppedLoading,
    strategyResultsStoppedLoadingError: state.strategies.strategyResultsStoppedLoadingError,

    strategyResultsHistory: state.strategies.strategyResultsHistory,
    strategyResultsHistoryLoading: state.strategies.strategyResultsHistoryLoading,
    strategyResultsHistoryLoadingError: state.strategies.strategyResultsHistoryLoadingError,
  }),
  (state) => state
);

export default strategiesSlice.reducer;
